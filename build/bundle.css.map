{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../TextAdder.svelte",
    "../../ChunkEditor.svelte",
    "../../SavedWordsHistory.svelte",
    "../../WordCollector.svelte",
    "../../DictionaryView.svelte",
    "../../Word.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import ChunkEditor from \"./ChunkEditor.svelte\"\n    import SavedWordsContainer from \"./SavedWordsHistory.svelte\"\n    import TextAdder from \"./TextAdder.svelte\"\n    import exportToCsv from \"./exportToCSV.js\"\n    import { persistSavedWords, retrieveSavedWords } from \"./utils.js\"\n    import md5 from \"md5\";\n    import _ from \"lodash\"\n\n    let texts = JSON.parse(localStorage.getItem(\"texts\") || '[]') // No Maybe in JS :(\n\n    let showTextAdder = texts.length == 0;\n\n    let currentlyEditing = {\n        textId: null,\n        chunk: null,\n        word: null\n    }\n\n    $: savedChunks = currentlyEditing.textId != null && retrieveSavedWords(texts[currentlyEditing.textId][0]) || {};\n\n    $: initialInput = currentlyEditing.chunk != null && currentlyEditing.word != null\n        ? savedChunks[currentlyEditing.chunk][currentlyEditing.word].input\n        : null\n    $: initialTranslation = currentlyEditing.chunk != null && currentlyEditing.word != null\n        ? savedChunks[currentlyEditing.chunk][currentlyEditing.word].translation\n        : null\n\n    function onSaveChunk({ detail }) {\n        const chunkId = currentlyEditing.chunk;\n\n        if(!savedChunks[chunkId])\n            savedChunks[chunkId] = [];\n\n        if(currentlyEditing.word == null) {\n            savedChunks[chunkId] = [...savedChunks[chunkId], detail];\n        } else {\n            savedChunks[chunkId][currentlyEditing.word] = detail;\n            currentlyEditing.word = null;\n        }\n\n        console.log(\"before:\",savedChunks);\n        persistSavedWords(texts[currentlyEditing.textId][0], savedChunks);\n        console.log(savedChunks);\n    }\n\n    function onCancelEdit() {\n        if(confirm(\"Cancel edit?\"))\n            currentlyEditing.word = null;\n    }\n\n    function selectSavedWord({ detail }) {\n        if(currentlyEditing.chunk == detail.chunk && currentlyEditing.word == detail.word) {\n            alert(\"You're currently editing this word.\");\n            return;\n        }\n\n        if(currentlyEditing.chunk != null && currentlyEditing.word != null) {\n            if(!confirm(\"You're currently editing '\" + initialInput + \"'. Discard?\")) {\n                return;\n            }\n        }\n\n        currentlyEditing.chunk = detail.chunk;\n        currentlyEditing.word = detail.word;\n    }\n\n    function download() {\n        const csvArray = _.flatMap(savedChunks).map(_.values);\n\n        if(!csvArray.length) {\n            alert(\"No saved chunks!\");\n            return;\n        }\n\n        exportToCsv(texts[currentlyEditing.textId][0] + \".csv\", csvArray);\n    }\n\n    function persistTexts(texts) {\n        localStorage.setItem(\"texts\", JSON.stringify(texts));\n    }\n\n    function addText({ detail: { title, lines } }) {\n        if(_.find(texts, o => o[0] == title)) {\n            alert(\"There is already a text with this title!\");\n            return;\n        }\n\n        texts = [...texts, [title, lines, 0]];\n        persistTexts(texts);\n\n        showTextAdder = false;\n    }\n\n    function selectText(i) {\n        if(currentlyEditing.word != null) {\n            alert(\"A word is currently being edited!\")\n            return\n        }\n\n        currentlyEditing.textId = i;\n        currentlyEditing.chunk = texts[i][2] || 0;\n    }\n\n    function switchChunk(dir) {\n        dir = dir > 0 ? 1 : -1; // Just in case...\n        if(currentlyEditing.word != null) {\n            alert(\"A word is currently being edited!\")\n            return\n        }\n\n        const nextChunkId = currentlyEditing.chunk + dir;\n\n        if(nextChunkId in texts[currentlyEditing.textId][1]) {\n            currentlyEditing.chunk = nextChunkId;\n            texts[currentlyEditing.textId][2] = nextChunkId;\n            persistTexts(texts);\n        }\n    }\n\n    function deleteText(i) {\n        if(!confirm(\"Delete text \", texts[i][0]))\n            return;\n\n        localStorage.removeItem(\"chunks-\" + md5(texts[i][0]));\n        texts.splice(i, 1);\n        persistTexts(texts);\n\n        currentlyEditing = {\n            textId: null,\n            chunk: null,\n            word: null\n        }\n    }\n\n    function deleteSavedWord({ detail }) {\n        if(!confirm(\"Wanna delete this word?\"))\n            return;\n\n        savedChunks[currentlyEditing.chunk].splice(detail, 1);\n        savedChunks[currentlyEditing.chunk] = savedChunks[currentlyEditing.chunk]\n        persistSavedWords(texts[currentlyEditing.textId][0], savedChunks);\n    }\n</script>\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css\">\n\n<style>\n    .grid { border: 1px solid black; }\n    a { display: block; }\n\n    .text-delete-list .text-delete-item a { float: left; }\n    .text-delete-list .text-delete-item > i { float: right; display: none; }\n    .text-delete-list .text-delete-item:hover > i { float: right; display: block; }\n\n    a.active-text-title {\n        color: #003;\n        text-decoration: underline;\n    }\n</style>\n\n<div class=\"ui stackable grid container\">\n    <div class=\"three wide column\">\n        <a href='#' on:click|preventDefault={download}>Export to CSV</a>\n        {#if !showTextAdder}\n            <a href='#' on:click|preventDefault={() => showTextAdder = true}>\n                Add a new text source\n            </a>\n        {/if}\n\n        {#if texts.length}\n            Choose a text source:\n            <div class=\"ui bulleted list text-delete-list\">\n                {#each texts as text, i (text[0])}\n                    <div class=\"item text-delete-item\">\n                        <a href=\"#\" on:click|preventDefault={() => selectText(i)}\n                           class=\"{i == currentlyEditing.textId ? \"active-text-title\" : \"\"}\">\n                           {text[0]}\n                        </a>\n                        <i class=\"close link red icon\" on:click={() => deleteText(i)} />\n                    </div>\n                {/each}\n            </div>\n        {/if}\n\n        <div class=\"centered column row\">\n            <SavedWordsContainer chunks={savedChunks} active={currentlyEditing}\n                                 on:selectSavedWord={selectSavedWord}\n                                 on:deleteSavedWord={deleteSavedWord}/>\n        </div>\n    </div>\n\n    <div class=\"thirteen wide column\">\n        {#if showTextAdder}\n            <div class=\"one column row\">\n                <TextAdder on:textAdded={addText} on:cancelEdit={() => showTextAdder = false} />\n            </div>\n        {/if}\n\n        <div class=\"row\">\n            {#if currentlyEditing.textId != null}\n                <ChunkEditor chunkText={texts[currentlyEditing.textId][1][currentlyEditing.chunk]}\n                             initialInput={initialInput}\n                             initialTranslation={initialTranslation}\n\n                             on:requestCancelEdit={onCancelEdit}\n                             on:saveChunk={onSaveChunk}\n                             on:changeChunk={({ detail }) => switchChunk(detail)}/>\n            {:else}\n                No text.\n                <div class=\"ui divider\" />\n            {/if}\n        </div>\n\n    </div>\n</div>\n\n",
    "<script>\n    import { normalizeLines } from \"./utils.js\"\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    let title = '', greatText = '',\n        splitStrategy = 0, joinIfShorter = true, joinIfShorterThan = 30;\n\n    const splitStrategies = [\n        [ 'Each line is a separate chunk.',\n            function () {\n                return greatText.split(/\\n+/g);\n            }\n        ], ['A chunk is a single sentence ending in any of \".\", \"!\" or \"?\".',\n            function() {\n                return greatText.split(/([.!?]+)/g)\n                    // The reduce now will bring the ending punctuation back to each sentence.\n                    .reduce((arr, next, i) => {\n                        if(i % 2 == 0) {\n                            arr.push(next); // Oh that hurts\n                            return arr;\n                        }\n                        arr[arr.length-1] += next;\n                        return arr;\n                    }, []);\n            }\n        ]\n    ];\n\n    function submit() {\n        let lines = splitStrategies[splitStrategy][1]();\n        lines = joinIfShorter ? normalizeLines(lines, joinIfShorterThan) : lines;\n\n        if(lines.length == 0) {\n            alert(\"No meaningful text entered. Refusing to add.\")\n            return;\n        }\n\n        dispatch(\"textAdded\", { title, lines });\n    }\n</script>\n\n<style>\n    textarea { width: 100%; height: 20em; }\n    input[type=\"number\"] { max-width: 2.5em; }\n\n    .form label { cursor: default; }\n\n    #min-elements-types { width: auto; }\n\n    .form .unpadded { padding: 0; }\n    .form .unbordered { border-top: 0; border-left: 0; border-right: 0; outline: 0; }\n\n    #join-if-shorter-number[disabled] { opacity: 0.4; }\n</style>\n\n<div class=\"ui form\">\n    <div class=\"field\">\n        <input bind:value={title} placeholder=\"Your wonderful text's title\" />\n    </div>\n\n    <div class=\"field\">\n        <textarea placeholder=\"Enter big text!\" bind:value={greatText} />\n    </div>\n\n    <div class=\"grouped fields\">\n        <label>Split strategy:</label>\n\n        {#each (splitStrategies) as strategy, i}\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input type=\"radio\"\n                           name=\"split-strategy\"\n                           value={i}\n                           bind:group={splitStrategy}\n                           id={\"strategy-option-\" + i} />\n                    <label for={\"strategy-option-\" + i}>{strategy[0]}</label>\n                </div>\n            </div>\n        {/each}\n\n        <div class=\"inline mini fields\">\n            <div class=\"ui checkbox\">\n                <input type=\"checkbox\"\n                       name=\"set-chunk-min-len\"\n                       bind:checked={joinIfShorter}\n                       id=\"no-short-lines-radio\" />\n\n                <label for=\"no-short-lines-radio\">\n                    Join chunks if shorter than\n                    <input type=\"number\" name=\"min-elements\" class=\"unpadded unbordered\" disabled={!joinIfShorter} bind:value={joinIfShorterThan} id=\"join-if-shorter-number\" />\n                    characters.\n                </label>\n            </div>\n        </div>\n\n        <button class=\"ui button\" on:click={submit}>Add!</button>\n        <button class=\"ui button\" on:click={() => dispatch(\"cancelEdit\")}>Abort</button>\n    </div>\n</div>\n",
    "<script>\n    import WordCollector from \"./WordCollector.svelte\";\n    import DictionaryView from \"./DictionaryView.svelte\"\n    import update from \"immutability-helper\"\n    import { tick, createEventDispatcher } from 'svelte';\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString, trimPunctuation, emphasizeWordInStr, inferEnteredFromInput, updateMarkedFromInput } from \"./utils.js\"\n    import _ from \"lodash\"\n\n    export let chunkText, initialInput = null, initialTranslation = null;\n\n    const dispatch = createEventDispatcher();\n\n    $: words = chunkText\n        .split(/[\\s–]+/)\n        .filter(w => trimPunctuation(w) != '')\n        .map(w => ({ word: w, marked: false  }));\n\n    $: inputValue = (chunkText, initialInput || '');\n    $: translationValue = (chunkText, initialTranslation || '');\n\n    $: marked = (chunkText, []);\n    $: dictionaryWord = (chunkText, '');\n\n    const saveConditions = [\n        [ () => inputValue != '' , 'No input entered!' ],\n        [ () => inputValue == dictionaryWord , 'input value not equal to translation value!' ],\n        [ () => translationValue != '', 'no translation entered' ]\n    ]\n\n    function toggleUnknown({ detail }) {\n        if(words[detail.i].marked)\n            inputValue = smartRemoveFromString(inputValue, detail.word.word)\n\n        words[detail.i] = wordToggleMark(words[detail.i]);\n        marked = arrayToggle(marked, wordUnmark(words[detail.i]));\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function toggleEntered({ detail: { word } }) {\n        inputValue = smartToggleSubstring(inputValue, word.word);\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function inputKeyup({ target }) {\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function applySearch() {\n        inputValue = trimPunctuation(inputValue);\n        dictionaryWord = inputValue\n    }\n\n    function clearInput() {\n        inputValue = '';\n    }\n\n    function checkSubmitConditions() {\n        for(let cond of saveConditions)\n            if(!(cond[0]()))\n                return cond[1];\n\n        return false;\n    }\n\n    function submit() {\n        let err = checkSubmitConditions();\n        if(err) {\n            alert(err);\n            return;\n        }\n\n        dispatch(\"saveChunk\", {\n            input: inputValue,\n            translation: translationValue,\n            context: emphasizeWordInStr(chunkText, inputValue)\n        });\n\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n    }\n\n    function switchChunk(dir) {\n        dir = dir > 0 ? 1 : -1;\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n        dispatch(\"changeChunk\", dir);\n    }\n\n    function goPrev() { switchChunk(-1); }\n    function goNext() { switchChunk(1); }\n\n    async function cancelEdit() {\n        dispatch(\"requestCancelEdit\");\n        await tick();\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function fireCombo(key, altKey) {\n        if(altKey && key == 'n')\n            switchChunk(1);\n        if(altKey && key == 'p')\n            switchChunk(-1);\n    }\n\n</script>\n\n<style>\n    .column { background: #F9FbFb; }\n    .form .translation {}\n</style>\n\n<svelte:window on:keydown={({ key, altKey }) => fireCombo(key, altKey)} />\n\n<div class=\"ui form\">\n<div class=\"ui stackable internally celled grid\">\n    <div class=\"eleven wide computer column\">\n        <h3 class=\"ui header\">Your text</h3>\n        <WordCollector words={words} markedClass=\"unknown\" on:wordClick={toggleUnknown} />\n    </div>\n    <div class=\"five wide computer column\">\n        <h3 class=\"ui header\">Marked words</h3>\n        <WordCollector words={marked} markedClass=\"entered\" on:wordClick={toggleEntered} />\n\n        <div class=\"segment\">\n            {#if initialInput}\n                <label>Currently editing: <i>{initialInput}</i></label>\n            {/if}\n            <div class=\"ui icon input\">\n                <input type=\"text\"\n                       placeholder=\"Search words\"\n                       bind:value={inputValue}\n                       on:keyup={inputKeyup}\n                       on:keydown={e => {if(e.keyCode == 13) applySearch()}} />\n                       <i class=\"close link icon\" on:click={clearInput}></i>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"sixteen wide column row\">\n        <DictionaryView searchTerm={dictionaryWord} />\n    </div>\n\n    <div class=\"row\">\n        <div class=\"sixteen wide column\">\n            <div class=\"field\">\n                <label> Select meaning:</label>\n                <div class=\"ui icon input fluid\">\n                    <textarea class=\"translation\"\n                              type=\"text\"\n                              rows=2\n                              placeholder=\"Meaning\"\n                              bind:value={translationValue} />\n                        <i class=\"close link icon\" on:click={() => translationValue=''} />\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\"column row centered\">\n        {#if initialInput}\n            <button class=\"ui button\" on:click={submit}>Update it!</button>\n            <button class=\"ui button\" on:click={cancelEdit}>Cancel editing \"{initialInput}\"</button>\n        {:else}\n            <button class=\"ui button\" on:click={goPrev}>«</button>\n            <button class=\"ui button\" on:click={submit}>Add word</button>\n            <button class=\"ui button\" on:click={goNext}>»</button>\n        {/if}\n    </div>\n</div>\n</div>\n",
    "<script>\n    import _ from \"lodash\"\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    export let chunks, active;\n\n    $: numberOfWords = _.reduce(chunks, (acc, val) => acc + val.length, 0)\n\n    console.log(chunks)\n</script>\n\n<style>\n    .saved-words {\n        outline: 1px dotted black;\n    }\n\n    .saved-word {\n        cursor: pointer;\n    }\n\n    .saved-words .saved-word > i.delete-saved-word {\n        display: none;\n        float: right;\n        margin-left: 1ex;\n    }\n\n    .saved-words .saved-word:hover > i.delete-saved-word {\n        display: inline-block;\n    }\n\n    .currently-editing {\n        font-style: italic;\n        opacity: 0.5;\n        cursor: disabled;\n        pointer-events: none;\n    }\n</style>\n\n{#if numberOfWords}\n    Saved ({numberOfWords}):\n    <!-- <div class=\"ui items \">\n    <div class=\"item\"> -->\n            <div class=\"ui bulleted list saved-words\">\n                {#each Object.keys(chunks) as chunkId}\n                    {#each chunks[chunkId] as savedWord, i}\n                        <div class=\"item saved-word {active.chunk == chunkId && active.word == i ? \"currently-editing\" : \"\"}\"\n                             on:click={() => dispatch(\"selectSavedWord\", {chunk: chunkId, word: i})}>\n                             <b>{savedWord.input}</b>:\n                             {savedWord.translation}\n\n                             <i class=\"close link red icon delete-saved-word\"\n                                on:click|stopPropagation={() => dispatch(\"deleteSavedWord\", i)} />\n                        </div>\n                    {/each}\n                {/each}\n            </div>\n        <!--</div>\n    </div>-->\n{:else}\n    The words you save will appear here.\n{/if}\n\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n    import Word from \"./Word.svelte\"\n    import _ from \"lodash\"\n\n    const dispatch = createEventDispatcher();\n\n    export let words, markedClass;\n</script>\n\n<style>\n    .word-collector {\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -khtml-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n    }\n</style>\n\n<div class=\"word-collector\">\n    {#each words as word, i}\n        <Word word={word} index={i} markedClass={markedClass} on:click={event => dispatch(\"wordClick\", { i, word, event })} />\n    {/each}\n</div>\n",
    "<script>\n    import update from \"immutability-helper\"\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString } from \"./utils.js\"\n    import _ from \"lodash\"\n\n    export let searchTerm;\n\n    let url = localStorage.getItem(\"dictionary\") || '';\n    let open = true;\n\n    function configureDict() {\n        let newUrl = prompt(\"Enter a dict url!\", \"https://\")\n        if(!/\\{\\}/.test(newUrl))\n            alert(\"Can't accept this url because it doesn't contain a'{}' to replace the word with.\");\n        else {\n            url = newUrl;\n            localStorage.setItem('dictionary', url);\n        }\n    }\n\n    function closeDict() {\n        open = false;\n    }\n</script>\n\n<style>\n    .dictionary {\n        position: relative;\n        display: block;\n        width: 100%;\n        padding: 1em;\n    }\n\n    iframe {\n        height: 500px;\n    }\n</style>\n\n<div class=\"dictionary\">\n    <a href=\"#\" on:click|preventDefault={configureDict} class=\"setup-button\">\n        Set up a dictionary URL.\n    </a>\n    {#if url}\n        {#if open}\n            <button on:click={closeDict} class=\"ui icon button \">\n                <i class=\"close link icon\"></i>\n                Close\n            </button>\n        {/if}\n        {#if searchTerm}\n            {#if open}\n                <iframe src={url.replace(\"{}\", searchTerm)} width=\"100%\" />\n            {:else}\n                <a href=\"#\" on:click|preventDefault={() => open = true}>Open the dictionary</a>\n            {/if}\n        {/if}\n    {:else}\n        {#if !searchTerm}\n            No search term entered.\n        {:else}\n            No url set up, can't look up \"{searchTerm}\"!\n        {/if}\n    {/if}\n\n</div>\n\n\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    export let word, index, markedClass;\n</script>\n\n<style>\n    .word-wrapper {\n        display: inline-block;\n        position: relative;\n    }\n\n    .word {\n        padding: 0.5ex;\n        cursor: pointer;\n        color: #0c0;\n        transition: background-color 0.5s;\n        text-align: center;\n    }\n\n    .word:hover {\n        background-color: #dfd;\n    }\n\n    .word.marked {\n        font-weight: bold;\n        text-decoration: underline;\n    }\n\n    .word::after {\n        /* Required to make the word occupy as much space as it would if it were *bold*.\n           Otherwise, adding the \"unknown\" class on a word makes it wider and\n           shifts the words right to it on the same line, which is not intended. */\n        display: block;\n        padding: 0 0.4ex;\n\n        content: attr(title);\n        font-weight: bold;\n        height: 0;\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .tooltip {\n        position: absolute;\n        top: -1.5ex;\n        left: 0;\n        padding-left: 1ex;\n        font-size: 1.5ex;\n        color: #444;\n        opacity: 0.8;\n    }\n\n    .word.unknown + .tooltip {\n        color: blue;\n        padding: 0 1ex;\n        opacity: 1;\n    }\n\n    .word.entered + .tooltip {\n        opacity: 1;\n    }\n</style>\n\n<div class=\"word-wrapper\">\n    <div class=\"word {word.marked ? \"marked \" + markedClass : \"\"}\"\n         title={word.word}\n         on:click>\n        {word.word}\n    </div>\n    <div class=\"tooltip\">\n        {index + 1}\n    </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}