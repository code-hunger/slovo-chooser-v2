{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../SavedWordsHistory.svelte",
    "../../ChunkEditor.svelte",
    "../../TextAdder.svelte",
    "../../TextSourceSelect.svelte",
    "../../DeletableItem.svelte",
    "../../WordCollector.svelte",
    "../../DictionaryView.svelte",
    "../../Word.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import ChunkEditor from \"./ChunkEditor.svelte\"\n    import SavedWordsContainer from \"./SavedWordsHistory.svelte\"\n    import TextAdder from \"./TextAdder.svelte\"\n    import TextSourceSelect from \"./TextSourceSelect.svelte\"\n    import exportToCsv, { exportToFile } from \"./exportToCSV.js\"\n    import { persistSavedWords, retrieveSavedWords } from \"./utils.js\"\n    import md5 from \"md5\";\n    import _ from \"lodash\"\n\n    let texts = JSON.parse(localStorage.getItem(\"texts\") || '[]') // No Maybe in JS :(\n\n    let showTextAdder = texts.length == 0;\n\n    let currentlyEditing = {\n        textId: null,\n        chunk: null,\n        word: null\n    }\n\n    $: savedChunks = currentlyEditing.textId != null && retrieveSavedWords(texts[currentlyEditing.textId][0]) || {};\n\n    $: initialInput = currentlyEditing.chunk != null && currentlyEditing.word != null\n        ? savedChunks[currentlyEditing.chunk][currentlyEditing.word].input\n        : null\n    $: initialTranslation = currentlyEditing.chunk != null && currentlyEditing.word != null\n        ? savedChunks[currentlyEditing.chunk][currentlyEditing.word].translation\n        : null\n\n    function onSaveChunk({ detail }) {\n        const chunkId = currentlyEditing.chunk;\n\n        if(!savedChunks[chunkId])\n            savedChunks[chunkId] = [];\n\n        if(currentlyEditing.word == null) {\n            savedChunks[chunkId] = [...savedChunks[chunkId], detail];\n        } else {\n            savedChunks[chunkId][currentlyEditing.word] = detail;\n            currentlyEditing.word = null;\n        }\n\n        console.log(\"before:\",savedChunks);\n        persistSavedWords(texts[currentlyEditing.textId][0], savedChunks);\n        console.log(savedChunks);\n    }\n\n    function onCancelEdit() {\n        if(confirm(\"Cancel edit?\"))\n            currentlyEditing.word = null;\n    }\n\n    function selectSavedWord({ detail }) {\n        if(currentlyEditing.chunk == detail.chunk && currentlyEditing.word == detail.word) {\n            alert(\"You're currently editing this word.\");\n            return;\n        }\n\n        if(currentlyEditing.chunk != null && currentlyEditing.word != null) {\n            if(!confirm(\"You're currently editing '\" + initialInput + \"'. Discard?\")) {\n                return;\n            }\n        }\n\n        currentlyEditing.chunk = detail.chunk;\n        currentlyEditing.word = detail.word;\n    }\n\n    function download() {\n        const csvArray = _.flatMap(savedChunks).map(_.values);\n\n        if(!csvArray.length) {\n            alert(\"No saved chunks!\");\n            return;\n        }\n\n        exportToCsv(texts[currentlyEditing.textId][0] + \".csv\", csvArray);\n    }\n\n    function combineAllState() {\n        let state = {};\n\n        for(let i = 0; i < localStorage.length; ++i) {\n            let name = localStorage.key(i);\n            state[name] = JSON.parse(localStorage.getItem(name));\n        }\n\n        return state;\n    }\n\n    function exportState() {\n        const fileName = \"slovo_choser_v2_state_\" + new Date().toISOString() + \".json\";\n        exportToFile(fileName, JSON.stringify(combineAllState()));\n    }\n\n    function persistTexts(texts) {\n        localStorage.setItem(\"texts\", JSON.stringify(texts));\n    }\n\n    function addText({ detail: { title, lines } }) {\n        if(_.find(texts, o => o[0] == title)) {\n            alert(\"There is already a text with this title!\");\n            return;\n        }\n\n        texts = [...texts, [title, lines, 0]];\n        persistTexts(texts);\n\n        showTextAdder = false;\n    }\n\n    function selectText(i) {\n        if(currentlyEditing.word != null) {\n            alert(\"A word is currently being edited!\")\n            return\n        }\n\n        currentlyEditing.textId = i;\n        currentlyEditing.chunk = parseInt(texts[i][2] || 0);\n    }\n\n    function switchChunk(dir) {\n        dir = dir > 0 ? 1 : -1; // Just in case...\n        if(currentlyEditing.word != null) {\n            alert(\"A word is currently being edited!\")\n            return\n        }\n\n        const nextChunkId = currentlyEditing.chunk + dir;\n\n        if(!(nextChunkId in texts[currentlyEditing.textId][1])) {\n            alert(\"Next chunk id \" + nextChunkId + \" not found in text.\");\n            return\n        }\n\n        currentlyEditing.chunk = nextChunkId;\n        texts[currentlyEditing.textId][2] = nextChunkId;\n        persistTexts(texts);\n    }\n\n    function deleteText(i) {\n        if(!confirm(\"Delete text \", texts[i][0]))\n            return;\n\n        localStorage.removeItem(\"chunks-\" + md5(texts[i][0]));\n        texts.splice(i, 1);\n        persistTexts(texts);\n\n        if(currentlyEditing.textId == i)\n            currentlyEditing = {\n                textId: null,\n                chunk: null,\n                word: null\n            }\n        else\n            // Need to trigger an update because of the call to texts.splice()\n            texts = texts;\n    }\n\n    function deleteSavedWord({ detail: { chunk, i} }) {\n        if(!confirm(\"Wanna delete this word?\"))\n            return;\n\n        savedChunks[chunk].splice(i, 1);\n        savedChunks[chunk] = savedChunks[chunk]\n        persistSavedWords(texts[currentlyEditing.textId][0], savedChunks);\n    }\n</script>\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css\">\n\n<style>\n    .grid { border: 1px solid black; }\n    a { display: block; }\n</style>\n\n<div class=\"ui stackable grid container\">\n    <div class=\"three wide column\">\n        <a href='#' on:click|preventDefault={download}>Export to CSV</a>\n        <a href='#' on:click|preventDefault={exportState}>Export whole state</a>\n        {#if !showTextAdder}\n            <a href='#' on:click|preventDefault={() => showTextAdder = true}>\n                Add a new text source\n            </a>\n        {/if}\n\n        <TextSourceSelect currentId={currentlyEditing.textId} {texts}\n                          on:select={({ detail }) => selectText(detail)}\n                          on:delete={({ detail }) => deleteText(detail)} />\n\n        <div class=\"centered column row\">\n            <SavedWordsContainer chunks={savedChunks} active={currentlyEditing}\n                                 on:select={selectSavedWord}\n                                 on:delete={deleteSavedWord}/>\n        </div>\n    </div>\n\n    <div class=\"thirteen wide column\">\n        {#if showTextAdder}\n            <div class=\"one column row\">\n                <TextAdder on:textAdded={addText} on:cancelEdit={() => showTextAdder = false} />\n            </div>\n        {/if}\n\n        <div class=\"row\">\n            {#if currentlyEditing.textId != null}\n                <ChunkEditor chunkText={texts[currentlyEditing.textId][1][currentlyEditing.chunk]}\n                             initialInput={initialInput}\n                             initialTranslation={initialTranslation}\n\n                             on:requestCancelEdit={onCancelEdit}\n                             on:saveChunk={onSaveChunk}\n                             on:changeChunk={({ detail }) => switchChunk(detail)}/>\n            {:else}\n                No text.\n            {/if}\n        </div>\n\n    </div>\n</div>\n\n",
    "<script>\n    import _ from \"lodash\"\n    import { createEventDispatcher } from 'svelte';\n    import DeletableItem from \"./DeletableItem.svelte\"\n\n    const dispatch = createEventDispatcher();\n\n    export let chunks, active;\n\n    $: numberOfWords = _.reduce(chunks, (acc, val) => acc + val.length, 0)\n\n    function makeDispatcher (name, chunk, word) {\n        return () => dispatch(name, {chunk, word});\n    }\n</script>\n\n<style>\n    .saved-word {\n        cursor: pointer;\n    }\n\n    .currently-editing {\n        text-decoration: underline;\n        color: #001f3f;\n        cursor: disabled;\n        pointer-events: none;\n    }\n</style>\n\n{#if numberOfWords}\n    Saved ({numberOfWords}):\n    <div class=\"ui bulleted list saved-words\">\n        {#each Object.keys(chunks) as chunkId}\n            {#each chunks[chunkId] as savedWord, i}\n                <DeletableItem disabled={active.chunk == chunkId && active.word == i}\n                               on:click={makeDispatcher('select', chunkId, i)}\n                               on:delete={makeDispatcher('delete', chunkId, i)}>\n                <div class=\"saved-word\" class:currently-editing={active.chunk == chunkId && active.word == i}>\n                    <b>{savedWord.input}</b>:\n                    {savedWord.translation}\n                </div>\n                </DeletableItem>\n            {/each}\n        {/each}\n    </div>\n{:else}\n    The words you save will appear here.\n{/if}\n\n",
    "<script>\n    import WordCollector from \"./WordCollector.svelte\";\n    import DictionaryView from \"./DictionaryView.svelte\"\n    import update from \"immutability-helper\"\n    import { tick, createEventDispatcher } from 'svelte';\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString, trimPunctuation, emphasizeWordInStr, inferEnteredFromInput, updateMarkedFromInput } from \"./utils.js\"\n    import _ from \"lodash\"\n\n    export let chunkText, initialInput = null, initialTranslation = null;\n\n    const dispatch = createEventDispatcher();\n\n    $: words = chunkText\n        .split(/[\\sâ€“]+/)\n        .filter(w => trimPunctuation(w) != '')\n        .map(w => ({ word: w, marked: false  }));\n\n    $: inputValue = (chunkText, initialInput || '');\n    $: translationValue = (chunkText, initialTranslation || '');\n\n    $: marked = (chunkText, []);\n    $: dictionaryWord = (chunkText, '');\n\n    const saveConditions = [\n        [ () => inputValue != '' , 'No input entered!' ],\n        [ () => inputValue == dictionaryWord , 'input value not equal to translation value!' ],\n        [ () => translationValue != '', 'no translation entered' ]\n    ]\n\n    function toggleUnknown({ detail }) {\n        if(words[detail.i].marked)\n            inputValue = smartRemoveFromString(inputValue, detail.word.word)\n\n        words[detail.i] = wordToggleMark(words[detail.i]);\n        marked = arrayToggle(marked, wordUnmark(words[detail.i]));\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function toggleEntered({ detail: { word } }) {\n        inputValue = smartToggleSubstring(inputValue, word.word);\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function inputKeyup({ target }) {\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function applySearch() {\n        inputValue = trimPunctuation(inputValue);\n        dictionaryWord = inputValue\n    }\n\n    function clearInput() {\n        inputValue = '';\n    }\n\n    function checkSubmitConditions() {\n        for(let cond of saveConditions)\n            if(!(cond[0]()))\n                return cond[1];\n\n        return false;\n    }\n\n    function submit() {\n        let err = checkSubmitConditions();\n        if(err) {\n            alert(err);\n            return;\n        }\n\n        dispatch(\"saveChunk\", {\n            input: inputValue,\n            translation: translationValue,\n            context: emphasizeWordInStr(chunkText, inputValue)\n        });\n\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n    }\n\n    function switchChunk(dir) {\n        dir = dir > 0 ? 1 : -1;\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n        dispatch(\"changeChunk\", dir);\n    }\n\n    function goPrev() { switchChunk(-1); }\n    function goNext() { switchChunk(1); }\n\n    async function cancelEdit() {\n        dispatch(\"requestCancelEdit\");\n        await tick();\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function fireCombo(key, altKey) {\n        if(altKey && key == 'n')\n            switchChunk(1);\n        if(altKey && key == 'p')\n            switchChunk(-1);\n    }\n\n</script>\n\n<style>\n    .column { background: #F9FbFb; }\n    .form .translation {}\n</style>\n\n<svelte:window on:keydown={({ key, altKey }) => fireCombo(key, altKey)} />\n\n<div class=\"ui form\">\n<div class=\"ui stackable celled grid\">\n    <div class=\"sixteen wide tablet eleven wide computer column\">\n        <h3 class=\"ui header\">Your text</h3>\n        <WordCollector words={words} markedClass=\"unknown\" on:wordClick={toggleUnknown} />\n    </div>\n    <div class=\"sixteen wide tablet five wide computer column\">\n        <h3 class=\"ui header\">Marked words</h3>\n        <WordCollector words={marked} markedClass=\"entered\" on:wordClick={toggleEntered} />\n\n        <div class=\"segment\">\n            {#if initialInput}\n                <label>Currently editing: <i>{initialInput}</i></label>\n            {/if}\n            <div class=\"ui action icon input\">\n                <input type=\"text\"\n                       placeholder=\"Search words\"\n                       bind:value={inputValue}\n                       on:keyup={inputKeyup}\n                       on:keydown={e => {if(e.keyCode == 13) applySearch()}} />\n                       <i class=\"close link icon\" on:click={clearInput}></i>\n                       <button class=\"ui icon button\" on:click={applySearch}>\n                           <i class=\"search icon\" />\n                       </button>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"sixteen wide column row\">\n        <DictionaryView searchTerm={dictionaryWord} />\n    </div>\n\n    <div class=\"row\">\n        <div class=\"sixteen wide column\">\n            <div class=\"field\">\n                <label> Select meaning:</label>\n                <div class=\"ui icon input fluid\">\n                    <textarea class=\"translation\"\n                              type=\"text\"\n                              rows=2\n                              placeholder=\"Meaning\"\n                              bind:value={translationValue} />\n                        <i class=\"close link icon\" on:click={() => translationValue=''} />\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"column row centered\">\n        {#if initialInput}\n            <button class=\"ui button\" on:click={submit}>Update it!</button>\n            <button class=\"ui button\" on:click={cancelEdit}>Cancel editing \"{initialInput}\"</button>\n        {:else}\n            <button class=\"ui button\" on:click={goPrev}>Â«</button>\n            <button class=\"ui button\" on:click={submit}>Add word</button>\n            <button class=\"ui button\" on:click={goNext}>Â»</button>\n        {/if}\n    </div>\n</div>\n</div>\n",
    "<script>\n    import { normalizeLines } from \"./utils.js\"\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    let title = '', greatText = '',\n        splitStrategy = 0, joinIfShorter = true, joinIfShorterThan = 30;\n\n    const splitStrategies = [\n        [ 'Each line is a separate chunk.',\n            function () {\n                return greatText.split(/\\n+/g);\n            }\n        ], ['A chunk is a single sentence ending in any of \".\", \"!\" or \"?\".',\n            function() {\n                return greatText.split(/([.!?]+)/g)\n                    // The reduce now will bring the ending punctuation back to each sentence.\n                    .reduce((arr, next, i) => {\n                        if(i % 2 == 0) {\n                            arr.push(next); // Oh that hurts\n                            return arr;\n                        }\n                        arr[arr.length-1] += next;\n                        return arr;\n                    }, []);\n            }\n        ]\n    ];\n\n    function submit() {\n        let lines = splitStrategies[splitStrategy][1]();\n        lines = joinIfShorter ? normalizeLines(lines, joinIfShorterThan) : lines;\n\n        if(lines.length == 0) {\n            alert(\"No meaningful text entered. Refusing to add.\")\n            return;\n        }\n\n        dispatch(\"textAdded\", { title, lines });\n    }\n</script>\n\n<style>\n    textarea { width: 100%; height: 20em; }\n    input[type=\"number\"] { max-width: 2.5em; }\n\n    .form label { cursor: default; }\n\n    #min-elements-types { width: auto; }\n\n    .form .unpadded { padding: 0; }\n    .form .unbordered { border-top: 0; border-left: 0; border-right: 0; outline: 0; }\n\n    #join-if-shorter-number[disabled] { opacity: 0.4; }\n</style>\n\n<div class=\"ui form\">\n    <div class=\"field\">\n        <input bind:value={title} placeholder=\"Your wonderful text's title\" />\n    </div>\n\n    <div class=\"field\">\n        <textarea placeholder=\"Enter big text!\" bind:value={greatText} />\n    </div>\n\n    <div class=\"grouped fields\">\n        <label>Split strategy:</label>\n\n        {#each (splitStrategies) as strategy, i}\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input type=\"radio\"\n                           name=\"split-strategy\"\n                           value={i}\n                           bind:group={splitStrategy}\n                           id={\"strategy-option-\" + i} />\n                    <label for={\"strategy-option-\" + i}>{strategy[0]}</label>\n                </div>\n            </div>\n        {/each}\n\n        <div class=\"inline mini fields\">\n            <div class=\"ui checkbox\">\n                <input type=\"checkbox\"\n                       name=\"set-chunk-min-len\"\n                       bind:checked={joinIfShorter}\n                       id=\"no-short-lines-radio\" />\n\n                <label for=\"no-short-lines-radio\">\n                    Join chunks if shorter than\n                    <input type=\"number\" name=\"min-elements\" class=\"unpadded unbordered\" disabled={!joinIfShorter} bind:value={joinIfShorterThan} id=\"join-if-shorter-number\" />\n                    characters.\n                </label>\n            </div>\n        </div>\n\n        <button class=\"ui button\" on:click={submit}>Add!</button>\n        <button class=\"ui button\" on:click={() => dispatch(\"cancelEdit\")}>Abort</button>\n    </div>\n</div>\n",
    "<script>\n    import { createEventDispatcher } from \"svelte\";\n    import DeletableItem from \"./DeletableItem.svelte\"\n\n    const dispatch = createEventDispatcher();\n\n    export let currentId, texts;\n\n    function makeDispatcher(name, word) {\n        return () => dispatch(name, word);\n    }\n</script>\n\n<svelte:options immutable={true} />\n\n<style>\n    .item-link {\n        /* colors from https://clrs.cc/ */\n        color: #0074D9;\n        cursor: pointer;\n\n        background: none;\n        border: none;\n        padding: 0;\n    }\n\n    .item-link.active-text-title {\n        color: #001f3f;\n        text-decoration: underline;\n    }\n</style>\n\n{#if texts.length}\n    Choose a text source:\n    <div class=\"ui bulleted list\">\n        {#each texts as text, i (text[0])}\n            <DeletableItem on:click={makeDispatcher(\"select\", i)} on:delete={makeDispatcher(\"delete\", i)}>\n                <div class=\"item-link\" class:active-text-title={i == currentId}>{text[0]}</div>\n            </DeletableItem>\n        {/each}\n    </div>\n{:else}\n    Your texts will appear here.\n{/if}\n\n",
    "<script>\n    import { createEventDispatcher } from \"svelte\";\n\n    const dispatch = createEventDispatcher();\n\n    export let classes = [], disabled = false;\n</script>\n\n<svelte:options immutable={true} />\n\n<style>\n    .item-holder { margin-right: 1.5em; /* space for the 'x' button */ }\n\n    .deletable-item > .delete-saved-word {\n        display: none ;\n        position: absolute;\n        right: 0;\n        top: 10%;\n    }\n\n    .non-button {\n        background: none;\n        border: none;\n        padding: 0;\n        /*optional*/\n        /*input has OS specific font-family*/\n    }\n\n    .deletable-item:hover > .delete-saved-word { display: block ; }\n</style>\n\n<div class=\"item deletable-item {classes.join(' ')}\" on:click={() => !disabled && dispatch(\"click\")}>\n    <button class=\"item-holder non-button\">\n        <slot />\n    </button>\n\n    {#if !disabled}\n        <button class=\"non-button delete-saved-word\">\n            <i class=\"close link red icon\" on:click|stopPropagation={() => dispatch(\"delete\")} />\n        </button>\n    {/if}\n</div>\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n    import Word from \"./Word.svelte\"\n    import _ from \"lodash\"\n\n    const dispatch = createEventDispatcher();\n\n    export let words, markedClass;\n</script>\n\n<style>\n    .word-collector {\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -khtml-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n    }\n</style>\n\n<div class=\"word-collector\">\n    {#each words as word, i}\n        <Word word={word} index={i} markedClass={markedClass} on:click={event => dispatch(\"wordClick\", { i, word, event })} />\n    {/each}\n</div>\n",
    "<script>\n    import update from \"immutability-helper\"\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString } from \"./utils.js\"\n    import _ from \"lodash\"\n\n    export let searchTerm;\n\n    let url = localStorage.getItem(\"dictionary\") || '';\n    let open = true;\n\n    function configureDict() {\n        let newUrl = prompt(\"Enter a dict url!\", \"https://\")\n        if(!/\\{\\}/.test(newUrl))\n            alert(\"Can't accept this url because it doesn't contain a'{}' to replace the word with.\");\n        else {\n            url = newUrl;\n            localStorage.setItem('dictionary', url);\n        }\n    }\n\n    function closeDict() {\n        open = false;\n    }\n</script>\n\n<style>\n    .dictionary {\n        position: relative;\n        display: block;\n        width: 100%;\n        padding: 1em;\n    }\n\n    iframe {\n        height: 500px;\n    }\n</style>\n\n<div class=\"dictionary\">\n    <a href=\"#\" on:click|preventDefault={configureDict} class=\"setup-button\">\n        Set up a dictionary URL.\n    </a>\n    {#if url}\n        {#if open}\n            <button on:click={closeDict} class=\"ui icon button \">\n                <i class=\"close link icon\"></i>\n                Close\n            </button>\n        {/if}\n        {#if searchTerm}\n            {#if open}\n                <iframe src={url.replace(\"{}\", searchTerm)} width=\"100%\" />\n            {:else}\n                <a href=\"#\" on:click|preventDefault={() => open = true}>Open the dictionary</a>\n            {/if}\n        {/if}\n    {:else}\n        {#if !searchTerm}\n            No search term entered.\n        {:else}\n            No url set up, can't look up \"{searchTerm}\"!\n        {/if}\n    {/if}\n\n</div>\n\n\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    export let word, index, markedClass;\n</script>\n\n<style>\n    .word-wrapper {\n        display: inline-block;\n        position: relative;\n    }\n\n    .word {\n        padding: 0.5ex;\n        cursor: pointer;\n        color: #0c0;\n        transition: background-color 0.5s;\n        text-align: center;\n    }\n\n    .word:hover {\n        background-color: #dfd;\n    }\n\n    .word.marked {\n        font-weight: bold;\n        text-decoration: underline;\n    }\n\n    .word::after {\n        /* Required to make the word occupy as much space as it would if it were *bold*.\n           Otherwise, adding the \"unknown\" class on a word makes it wider and\n           shifts the words right to it on the same line, which is not intended. */\n        display: block;\n        padding: 0 0.4ex;\n\n        content: attr(title);\n        font-weight: bold;\n        height: 0;\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .tooltip {\n        position: absolute;\n        top: -1.5ex;\n        left: 0;\n        padding-left: 1ex;\n        font-size: 1.5ex;\n        color: #444;\n        opacity: 0.8;\n    }\n\n    .word.unknown + .tooltip {\n        color: blue;\n        padding: 0 1ex;\n        opacity: 1;\n    }\n\n    .word.entered + .tooltip {\n        opacity: 1;\n    }\n</style>\n\n<div class=\"word-wrapper\">\n    <div class=\"word {word.marked ? \"marked \" + markedClass : \"\"}\"\n         title={word.word}\n         on:click>\n        {word.word}\n    </div>\n    <div class=\"tooltip\">\n        {index + 1}\n    </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}