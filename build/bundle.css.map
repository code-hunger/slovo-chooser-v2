{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../ChunkEditor.svelte",
    "../../SavedWordsHistory.svelte",
    "../../TextAdder.svelte",
    "../../TextSourceSelect.svelte",
    "../../WordCollector.svelte",
    "../../DictionaryView.svelte",
    "../../InputSearchWord.svelte",
    "../../ContextStrategyChooser.svelte",
    "../../DeletableItem.svelte",
    "../../Word.svelte",
    "../../PartialContextSelector.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import ChunkEditor from \"./ChunkEditor.svelte\"\n    import SavedWordsContainer from \"./SavedWordsHistory.svelte\"\n    import TextAdder from \"./TextAdder.svelte\"\n    import TextSourceSelect from \"./TextSourceSelect.svelte\"\n    import exportToCsv from \"./exportToCSV.js\"\n    import { persistSavedWords, retrieveSavedWords, savedWordDeleterCreator, textDeleterCreator, switchChunkCreator, persistTexts, onSaveChunkCreator, downloadSavedWords, exportState } from \"./utils.js\"\n    import md5 from \"md5\";\n    import _ from \"lodash\"\n\n    let texts = JSON.parse(localStorage.getItem(\"texts\") || '[]') // No Maybe in JS :(\n\n    let showTextAdder = texts.length == 0;\n\n    let currentlyEditing = {\n        textId: null,\n        chunk: null,\n        word: null\n    }\n\n    $: savedChunks = currentlyEditing.textId != null && retrieveSavedWords(texts[currentlyEditing.textId][0]) || {};\n\n    $: initial = currentlyEditing.chunk != null && currentlyEditing.word != null\n        ? savedChunks[currentlyEditing.chunk][currentlyEditing.word]\n        : null\n\n    function onCancelEdit() {\n        if(confirm(\"Cancel edit?\"))\n            currentlyEditing.word = null;\n    }\n\n    function selectSavedWord({ detail }) {\n        if(currentlyEditing.chunk == detail.chunk && currentlyEditing.word == detail.word) {\n            alert(\"You're currently editing this word.\");\n            return;\n        }\n\n        if(currentlyEditing.chunk != null && currentlyEditing.word != null) {\n            if(!confirm(\"You're currently editing '\" + initial.input + \"'. Discard?\")) {\n                return;\n            }\n        }\n\n        // `detail.chunk` comes as a key from savedChunks and hence is a String,\n        // which makes further integer operations behave badly ('14' + 1 = 141 :/)\n        currentlyEditing.chunk = parseInt(detail.chunk);\n        currentlyEditing.word = detail.word;\n    }\n\n    function addText({ detail: { title, lines } }) {\n        if(_.find(texts, o => o[0] == title)) {\n            alert(\"There is already a text with this title!\");\n            return;\n        }\n\n        textsUpdater([...texts, [title, lines, 0]]);\n\n        showTextAdder = false;\n    }\n\n    function selectText(i) {\n        if(!Number.isFinite(i)) {\n            alert(\"The selected 'thing' is not an id of a text: \", i);\n            console.log(\"This is not an id of a text: \", i);\n            return;\n        }\n\n        if(currentlyEditing.word != null) {\n            alert(\"A word is currently being edited!\")\n            return\n        }\n\n        currentlyEditing.textId = i;\n        currentlyEditing.chunk = parseInt(texts[i][2] || 0);\n    }\n\n    function savedChunksUpdater(chunk, newValue) {\n        savedChunks[chunk] = newValue;\n        persistSavedWords(texts[currentlyEditing.textId][0], savedChunks);\n    }\n    function currentSavedChunksUpdater(newValue) {\n        savedChunksUpdater(currentlyEditing.chunk, newValue);\n    }\n\n    function currentChunkIdUpdater(newChunkId) {\n        if(typeof newChunkId !== \"number\") { alert(\"Internall type error!\") }\n        currentlyEditing.chunk = newChunkId;\n        texts[currentlyEditing.textId][2] = newChunkId;\n        persistTexts(texts);\n    }\n\n    function resetCurrentlyEditing() {\n        currentlyEditing = { textId: null, chunk: null, word: null }\n    }\n    function resetCurrentWord() { currentlyEditing.word = null; }\n\n    function textsUpdater(newTexts) {\n        texts = newTexts;\n        persistTexts(texts);\n    }\n\n    const textDeleter = textDeleterCreator(resetCurrentlyEditing, textsUpdater);\n    const savedWordDeleter = savedWordDeleterCreator(savedChunksUpdater, resetCurrentWord);\n    const switchChunk = switchChunkCreator(currentChunkIdUpdater);\n    const onSaveChunk = onSaveChunkCreator(resetCurrentWord, currentSavedChunksUpdater);\n    const download = () => downloadSavedWords(texts[currentlyEditing.textId][0], savedChunks)\n</script>\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css\">\n\n<style>\n    .grid { border: 1px solid black; }\n    a { display: block; }\n</style>\n\n<div class=\"ui stackable grid container\">\n    <div class=\"three wide column\">\n        <a href='#' on:click|preventDefault={download}>Export to CSV</a>\n        <a href='#' on:click|preventDefault={exportState}>Export whole state</a>\n        {#if !showTextAdder}\n            <a href='#' on:click|preventDefault={() => showTextAdder = true}>\n                Add a new text source\n            </a>\n        {/if}\n\n        <TextSourceSelect currentId={currentlyEditing.textId} {texts}\n                          on:select={({ detail }) => selectText(detail)}\n                          on:delete={textDeleter(currentlyEditing.textId, texts)} />\n\n        <div class=\"centered column row\">\n            <SavedWordsContainer chunks={savedChunks} active={currentlyEditing}\n                                 on:select={selectSavedWord}\n                                 on:delete={savedWordDeleter(currentlyEditing, savedChunks)}/>\n        </div>\n    </div>\n\n    <div class=\"thirteen wide column\">\n        {#if showTextAdder}\n            <div class=\"one column row\">\n                <TextAdder on:textAdded={addText} on:cancelEdit={() => showTextAdder = false} />\n            </div>\n        {/if}\n\n        <div class=\"row\">\n            {#if currentlyEditing.textId != null}\n                <ChunkEditor chunkText={texts[currentlyEditing.textId][1][currentlyEditing.chunk]}\n                             {initial}\n\n                             on:requestCancelEdit={onCancelEdit}\n                             on:saveChunk={onSaveChunk(currentlyEditing.word, savedChunks[currentlyEditing.chunk])}\n                             on:changeChunk={switchChunk(currentlyEditing, texts[currentlyEditing.textId])}/>\n            {:else}\n                No text.\n            {/if}\n        </div>\n\n    </div>\n</div>\n\n",
    "<script>\n    import WordCollector from \"./WordCollector.svelte\";\n    import DictionaryView from \"./DictionaryView.svelte\"\n    import InputSearchWord from \"./InputSearchWord.svelte\"\n    import update from \"immutability-helper\"\n    import { tick, createEventDispatcher } from 'svelte';\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString, trimPunctuation, emphasizeWordInStr, inferEnteredFromInput, updateMarkedFromInput } from \"./utils.js\"\n    import ContextStrategyChooser from \"./ContextStrategyChooser.svelte\";\n    import _ from \"lodash\"\n\n\timport { slide } from 'svelte/transition';\n\n    export let chunkText, initial = { input: '', translation: '', context: '' };\n\n    const dispatch = createEventDispatcher();\n\n    $: words = chunkText\n        .split(/[\\sâ€“]+/)\n        .filter(w => trimPunctuation(w) != '')\n        .map(w => ({ word: w, marked: false  }));\n\n    $: inputValue = (chunkText, initial && initial.input || '');\n    $: translationValue = (chunkText, initial && initial.translation || '');\n\n    $: marked = (chunkText, []);\n    $: dictionaryWord = (chunkText, '');\n\n    $: showContextSelector = showContextSelector || (inputValue && translationValue);\n\n    let selectedContext = '';\n\n    const saveConditions = [\n        [ () => inputValue != '' , 'No input entered!' ],\n        [ () => inputValue == dictionaryWord , 'input value not equal to translation value!' ],\n        [ () => translationValue != '', 'no translation entered' ]\n    ]\n\n    function toggleUnknown({ detail }) {\n        if(words[detail.i].marked)\n            inputValue = smartRemoveFromString(inputValue, detail.word.word)\n        else\n            if(trimPunctuation(inputValue) == \"\")\n                inputValue = detail.word.word;\n\n        words[detail.i] = wordToggleMark(words[detail.i]);\n        marked = arrayToggle(marked, wordUnmark(words[detail.i]));\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function toggleEntered({ detail: { word } }) {\n        inputValue = smartToggleSubstring(inputValue, word.word);\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function inputKeyup({ target }) {\n        marked = updateMarkedFromInput(marked, inputValue);\n    }\n\n    function applySearch() { dictionaryWord = inputValue }\n\n    function checkSubmitConditions() {\n        for(let cond of saveConditions)\n            if(!(cond[0]()))\n                return cond[1];\n\n        return false;\n    }\n\n    function submit() {\n        let err = checkSubmitConditions();\n        if(err) {\n            alert(err);\n            return;\n        }\n\n        dispatch(\"saveChunk\", {\n            input: inputValue,\n            translation: translationValue,\n            context: emphasizeWordInStr(selectedContext, inputValue)\n        });\n\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n        showContextSelector = false;\n    }\n\n    function switchChunk(dir) {\n        dir = dir > 0 ? 1 : -1;\n        inputValue = ''\n        dictionaryWord = ''\n        translationValue = ''\n        dispatch(\"changeChunk\", dir);\n        showContextSelector = false;\n    }\n\n    function goPrev() { switchChunk(-1); }\n    function goNext() { switchChunk(1); }\n\n    async function cancelEdit() {\n        dispatch(\"requestCancelEdit\");\n        await tick();\n        marked = updateMarkedFromInput(marked, inputValue);\n        showContextSelector = false;\n    }\n\n    function fireCombo(key, altKey) {\n        if(altKey && key == 'n')\n            switchChunk(1);\n        if(altKey && key == 'p')\n            switchChunk(-1);\n    }\n</script>\n\n<style>\n    .row, .column { background: #F9FbFb; }\n    .form .translation {}\n</style>\n\n<svelte:window on:keydown={({ key, altKey }) => fireCombo(key, altKey)} />\n\n<div class=\"ui form\">\n<div class=\"ui stackable celled grid\">\n    <div class=\"sixteen wide tablet ten wide computer column\">\n        <h3 class=\"ui header\">Your text</h3>\n        <WordCollector words={words} markedClass=\"unknown\" on:wordClick={toggleUnknown} />\n    </div>\n    <div class=\"sixteen wide tablet six wide computer column\">\n        <h3 class=\"ui header\">Marked words</h3>\n        <WordCollector words={marked} markedClass=\"entered\" on:wordClick={toggleEntered} />\n\n        <div class=\"segment\">\n            <InputSearchWord bind:inputValue initialInput={initial && initial.input} on:inputKeyup={inputKeyup} on:applySearch={applySearch} wasSearched={inputValue == dictionaryWord} />\n        </div>\n    </div>\n\n    <div class=\"sixteen wide column row\">\n        <DictionaryView searchTerm={dictionaryWord} />\n    </div>\n\n    <div class=\"row\">\n        <div class=\"sixteen wide column\">\n            <div class=\"field\">\n                <label> Select meaning:</label>\n                <div class=\"ui icon input fluid\">\n                    <textarea class=\"translation\"\n                              type=\"text\"\n                              rows=2\n                              placeholder=\"Meaning\"\n                              bind:value={translationValue} />\n                        <i class=\"close link icon\" on:click={() => translationValue=''} />\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- No need to show the context selector before selecting a word and a translation -->\n    {#if showContextSelector}\n        <div class=\"column row\" transition:slide={{delay: 1000}}>\n            <ContextStrategyChooser words={words} initialContext={initial && initial.context} bind:selectedContext />\n        </div>\n    {/if}\n\n    <div class=\"column row centered\">\n        {#if initial && initial.input}\n            <button class=\"ui button\" on:click={submit}>Update it!</button>\n            <button class=\"ui button\" on:click={cancelEdit}>Cancel editing \"{initial.input}\"</button>\n        {:else}\n            <button class=\"ui button\" on:click={goPrev}>Â«</button>\n            <button class=\"ui button\" on:click={submit}>Add word</button>\n            <button class=\"ui button\" on:click={goNext}>Â»</button>\n        {/if}\n    </div>\n</div>\n</div>\n",
    "<script>\n    import _ from \"lodash\"\n    import { createEventDispatcher } from 'svelte';\n    import DeletableItem from \"./DeletableItem.svelte\"\n\n    const dispatch = createEventDispatcher();\n\n    export let chunks, active;\n\n    $: numberOfWords = _.reduce(chunks, (acc, val) => acc + val.length, 0)\n\n    function makeDispatcher (name, chunk, word) {\n        return () => dispatch(name, {chunk, word});\n    }\n</script>\n\n<style>\n    .saved-word {\n        cursor: pointer;\n    }\n\n    .currently-editing {\n        text-decoration: underline;\n        color: #001f3f;\n        cursor: disabled;\n        pointer-events: none;\n    }\n</style>\n\n{#if numberOfWords}\n    Saved ({numberOfWords}):\n    <div class=\"ui bulleted list saved-words\">\n        {#each Object.keys(chunks) as chunkId}\n            {#each chunks[chunkId] as savedWord, i}\n                <DeletableItem on:click={makeDispatcher('select', chunkId, i)}\n                               on:delete={makeDispatcher('delete', chunkId, i)}>\n                    <div class=\"saved-word\"\n                         class:currently-editing={active.chunk == chunkId && active.word == i}\n                         tabindex=0>\n                        <b>{savedWord.input}</b>:\n                        {savedWord.translation}\n                    </div>\n                </DeletableItem>\n            {/each}\n        {/each}\n    </div>\n{:else}\n    The words you save will appear here.\n{/if}\n\n",
    "<script>\n    import { normalizeLines } from \"./utils.js\"\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    let title = '', greatText = '',\n        splitStrategy = 0, joinIfShorter = true, joinIfShorterThan = 30;\n\n    const splitStrategies = [\n        {\n            description: 'Each line is a separate chunk.',\n            action: bigText => bigText.split(/\\n+/g)\n        },\n        {\n            description: 'A chunk is a single sentence ending in any of \".\", \"!\" or \"?\".',\n            action: bigText => bigText.split(/([.!?]+)/g)\n                // The reduce now will bring the ending punctuation back to each sentence.\n                .reduce((arr, next, i) => {\n                    if(i % 2 == 0) {\n                        arr.push(next); // Oh that hurts\n                        return arr;\n                    }\n                    arr[arr.length-1] += next;\n                    return arr;\n                }, [])\n        }\n    ];\n\n    function submit() {\n        let lines = splitStrategies[splitStrategy].action(greatText);\n        lines = joinIfShorter ? normalizeLines(lines, joinIfShorterThan) : lines;\n\n        if(lines.length == 0) {\n            alert(\"No meaningful text entered. Refusing to add.\")\n            return;\n        }\n\n        dispatch(\"textAdded\", { title, lines });\n    }\n</script>\n\n<style>\n    textarea { width: 100%; height: 20em; }\n    input[type=\"number\"] { max-width: 2.5em; }\n\n    .form label { cursor: default; }\n\n    #min-elements-types { width: auto; }\n\n    .form .unpadded { padding: 0; }\n    .form .unbordered { border-top: 0; border-left: 0; border-right: 0; outline: 0; }\n\n    #join-if-shorter-number[disabled] { opacity: 0.4; }\n</style>\n\n<div class=\"ui form\">\n    <div class=\"field\">\n        <input bind:value={title} placeholder=\"Your wonderful text's title\" />\n    </div>\n\n    <div class=\"field\">\n        <textarea placeholder=\"Enter big text!\" bind:value={greatText} />\n    </div>\n\n    <div class=\"grouped fields\">\n        <label>Split strategy:</label>\n\n        {#each (splitStrategies) as strategy, i}\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input type=\"radio\"\n                           name=\"split-strategy\"\n                           value={i}\n                           bind:group={splitStrategy}\n                           id={\"strategy-option-\" + i} />\n                    <label for={\"strategy-option-\" + i}>{strategy.description}</label>\n                </div>\n            </div>\n        {/each}\n\n        <div class=\"inline mini fields\">\n            <div class=\"ui checkbox\">\n                <input type=\"checkbox\"\n                       name=\"set-chunk-min-len\"\n                       bind:checked={joinIfShorter}\n                       id=\"no-short-lines-radio\" />\n\n                <label for=\"no-short-lines-radio\">\n                    Join chunks if shorter than\n                    <input type=\"number\" name=\"min-elements\" class=\"unpadded unbordered\" disabled={!joinIfShorter} bind:value={joinIfShorterThan} id=\"join-if-shorter-number\" />\n                    characters.\n                </label>\n            </div>\n        </div>\n\n        <button class=\"ui button\" on:click={submit}>Add!</button>\n        <button class=\"ui button\" on:click={() => dispatch(\"cancelEdit\")}>Abort</button>\n    </div>\n</div>\n",
    "<script>\n    import { createEventDispatcher } from \"svelte\";\n    import DeletableItem from \"./DeletableItem.svelte\"\n\n    const dispatch = createEventDispatcher();\n\n    export let currentId, texts;\n\n    function makeDispatcher(name, word) {\n        return () => dispatch(name, word);\n    }\n</script>\n\n<style>\n    .item { cursor: pointer; }\n\n    /* colors from https://clrs.cc/ */\n    .item-link { color: #0074D9; }\n\n    .item-link.active-text-title {\n        color: #001f3f;\n        text-decoration: underline;\n    }\n</style>\n\n{#if texts.length}\n    Choose a text source:\n    <div class=\"ui bulleted list\">\n        {#each texts as text, i (text[0])}\n            <DeletableItem on:click={makeDispatcher(\"select\", i)} on:delete={makeDispatcher(\"delete\", i)}>\n                <div class=\"item\" class:active-text-title={i == currentId} tabindex=0>\n                    <span class=\"item-link\">\n                        {text[0]}\n                    </span>\n                    ({text[2] + 1} / {text[1].length})\n                </div>\n            </DeletableItem>\n        {/each}\n    </div>\n{:else}\n    Your texts will appear here.\n{/if}\n\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n    import Word from \"./Word.svelte\"\n    import _ from \"lodash\"\n\n    const dispatch = createEventDispatcher();\n\n    export let words, markedClass;\n</script>\n\n<style>\n    .word-collector {\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -khtml-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n    }\n</style>\n\n<div class=\"word-collector\">\n    {#each words as word, i}\n        <Word word={word} index={i} markedClass={markedClass} on:click={event => dispatch(\"wordClick\", { i, word, event })} />\n    {/each}\n</div>\n",
    "<script>\n    import update from \"immutability-helper\"\n    import { arrayToggle, wordToggleMark, wordUnmark, containsWord, smartToggleSubstring, smartRemoveFromString } from \"./utils.js\"\n    import _ from \"lodash\"\n\n    export let searchTerm;\n\n    let url = JSON.parse(localStorage.getItem(\"dictionary\") || '\"\"');\n    let open = true;\n\n    function configureDict() {\n        let newUrl = prompt(\"Enter a dict url!\", \"https://\")\n        if(!/\\{\\}/.test(newUrl))\n            alert(\"Can't accept this url because it doesn't contain a '{}' to replace the word with.\");\n        else {\n            url = newUrl;\n            localStorage.setItem('dictionary', JSON.stringify(url));\n        }\n    }\n\n    function closeDict() {\n        open = false;\n    }\n</script>\n\n<style>\n    .dictionary {\n        position: relative;\n        display: block;\n        width: 100%;\n        padding: 1em;\n    }\n\n    iframe {\n        height: 500px;\n    }\n</style>\n\n<div class=\"dictionary\">\n    <a href=\"#\" on:click|preventDefault={configureDict} class=\"setup-button\">\n        Set up a dictionary URL.\n    </a>\n    {#if url}\n        {#if open}\n            <button on:click={closeDict} class=\"ui icon button \">\n                <i class=\"close link icon\"></i>\n                Close\n            </button>\n        {/if}\n        {#if searchTerm}\n            {#if open}\n                <iframe src={url.replace(\"{}\", searchTerm)} width=\"100%\" />\n            {:else}\n                <a href=\"#\" on:click|preventDefault={() => open = true}>Open the dictionary</a>\n            {/if}\n        {/if}\n    {:else}\n        {#if !searchTerm}\n            No search term entered.\n        {:else}\n            No url set up, can't look up \"{searchTerm}\"!\n        {/if}\n    {/if}\n\n</div>\n\n\n",
    "<script>\n    import { trimPunctuation } from \"./utils.js\"\n    import { tick, createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    export let inputValue, initialInput, wasSearched;\n\n    function clearInput() {\n        inputValue = '';\n    }\n\n    $: console.log(wasSearched);\n\n    function searchLowercase() { inputValue = inputValue.toLowerCase(); dispatch('inputKeyup') }\n    function searchBackspace() { inputValue = inputValue.slice(0, -1); dispatch('inputKeyup') }\n    function searchTrim() { inputValue = trimPunctuation(inputValue).trim(); }\n\n    function applySearch() {\n        searchTrim();\n        dispatch('applySearch')\n    }\n</script>\n\n<style>\n    .input input.myinput.was-searched {\n        color: darkgreen;\n    }\n</style>\n\n{#if initialInput}\n    <label>Currently editing: <i>{initialInput}</i></label>\n{/if}\n\n{#if inputValue}\n    <div>\n        <a href=\"#\" on:click={searchLowercase}><i class=\"arrow alternate circle down outline icon\" /></a>\n        <a href=\"#\" on:click={searchBackspace}><i class=\"arrow alternate circle left outline icon\" /></a>\n        <a href=\"#\" on:click={searchTrim}><i class=\"cut icon\" /></a>\n    </div>\n{/if}\n\n<div class=\"ui action icon input\">\n    <input type=\"text\"\n           placeholder=\"Search words\"\n           class=\"myinput\"\n           class:was-searched={wasSearched}\n           bind:value={inputValue}\n           on:keyup={e => dispatch('inputKeyup', e)}\n           on:keydown={e => {if(e.keyCode == 13) applySearch()}} />\n   <i class=\"close link icon\" on:click={clearInput}></i>\n   <button class=\"ui icon button\" on:click={applySearch}>\n       <i class=\"search icon\" />\n   </button>\n</div>\n",
    "<script>\n    import PartialContextSelector from \"./PartialContextSelector.svelte\";\n    import KeepContextSelector from \"./KeepContextSelector.svelte\";\n    import ManualContextSelector from \"./ManualContextSelector.svelte\"\n\n    export let chosenStrategy, words, initialContext = '', selectedContext;\n\n    $: chosenStrategy = (!initialContext && 3 || 0);\n\n    $: strategies = [\n        {\n            desc: \"Keep same (no changes)\",\n            viable: initialContext && initialContext.length > 0,\n            component: KeepContextSelector,\n            properties: { initialContext },\n            activate() {}\n        },\n        {\n            desc: 'Empty context',\n            viable: true,\n            activate() { selectedContext = ''; }\n        },\n        {\n            desc: 'Use the whole chunk as a context',\n            viable: true,\n            activate() { selectedContext = words.map(w => w.word).join(' ') }\n        },\n        {\n            desc:'Choose only part of the chunk to use as a context.',\n            viable: true,\n            component: PartialContextSelector,\n            properties: { words, selectedContext },\n            activate() {}\n        },\n        {\n            desc: \"Manually select context\",\n            viable: true,\n            component: ManualContextSelector,\n            properties: {},\n            activate() {}\n        }\n    ];\n</script>\n\n<style type=\"text/css\" media=\"screen\">\n    .form label { cursor: default; }\n\n    .column { background: inherit; }\n</style>\n\n{#if words}\n    <div class=\"seven wide column\">\n        <div class=\"ui form\">\n            <div class=\"grouped fields\">\n                {#each (strategies) as strategy, i}\n                    {#if strategy.viable}\n                        <div class=\"field\">\n                            <div class=\"ui radio checkbox\">\n                                <input type=\"radio\"\n                                       name=\"context-strategy\"\n                                       value={i}\n                                       bind:group={chosenStrategy}\n                                       on:change={strategy.activate}\n                                       id={\"context-strategy-option-\" + i} />\n                                <label for={\"context-strategy-option-\" + i}>{strategy.desc}</label>\n                            </div>\n                        </div>\n                    {/if}\n                {/each}\n            </div>\n        </div>\n    </div>\n\n    {#if strategies[chosenStrategy].component}\n        <div class=\"nine wide column\">\n            <svelte:component\n                this={strategies[chosenStrategy].component}\n                bind:selectedContext\n                {...strategies[chosenStrategy].properties} />\n        </div>\n    {/if}\n{:else}\n    No words :( So no context could be selected.\n{/if}\n",
    "<script>\n    import { createEventDispatcher } from \"svelte\";\n\n    const dispatch = createEventDispatcher();\n\n    export let classes = [], disabled = false;\n</script>\n\n<style>\n    .item-holder {\n        /* space for the 'x' button, because it has absolute position */\n        margin-right: 1.5em;\n    }\n\n    .deletable-item > .delete-saved-word {\n        display: none ;\n        position: absolute;\n        right: 0;\n        top: 10%;\n    }\n\n    .non-button {\n        background: none;\n        border: none;\n        padding: 0;\n    }\n\n    .deletable-item:hover > .delete-saved-word,\n    .deletable-item:focus > .delete-saved-word { display: block ; }\n</style>\n\n<div class=\"item deletable-item {classes.join(' ')}\"\n     on:click={() => !disabled && dispatch(\"click\")}>\n    <div class=\"item-holder\">\n        <slot />\n    </div>\n\n    {#if !disabled}\n        <button class=\"non-button delete-saved-word\">\n            <i class=\"close link red icon\" on:click|stopPropagation={() => dispatch(\"delete\")} />\n        </button>\n    {/if}\n</div>\n",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    export let word, index, markedClass;\n</script>\n\n<style>\n    .word-wrapper {\n        display: inline-block;\n        position: relative;\n    }\n\n    .word {\n        padding: 0.5ex;\n        cursor: pointer;\n        color: #0c0;\n        transition: background-color 0.5s;\n        text-align: center;\n    }\n\n    .word:hover {\n        background-color: #dfd;\n    }\n\n    .word.marked {\n        font-weight: bold;\n        text-decoration: underline;\n    }\n\n    .word::after {\n        /* Required to make the word occupy as much space as it would if it were *bold*.\n           Otherwise, adding the \"unknown\" class on a word makes it wider and\n           shifts the words right to it on the same line, which is not intended. */\n        display: block;\n        padding: 0 0.4ex;\n\n        content: attr(title);\n        font-weight: bold;\n        height: 0;\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .tooltip {\n        position: absolute;\n        top: -1.5ex;\n        left: 0;\n        padding-left: 1ex;\n        font-size: 1.5ex;\n        color: #444;\n        opacity: 0.8;\n    }\n\n    .word.unknown + .tooltip {\n        color: blue;\n        padding: 0 1ex;\n        opacity: 1;\n    }\n\n    .word.entered + .tooltip {\n        opacity: 1;\n    }\n</style>\n\n<div class=\"word-wrapper\">\n    <div class=\"word {word.marked ? \"marked \" + markedClass : \"\"}\"\n         title={word.word}\n         on:click>\n        {word.word}\n    </div>\n    <div class=\"tooltip\">\n        {index + 1}\n    </div>\n</div>\n",
    "<script>\n    /*import 'nouislider/distribute/nouislider.css';*/\n    import noUiSlider from 'nouislider';\n\timport { onMount } from 'svelte';\n\n    export let words, selectedContext;\n\n    const chosenEnds = { start: 0, end: words.length - 1 };\n    const DEFAULT_WORDS = 15;\n\n    $: selectedContext = words.slice(chosenEnds.start, chosenEnds.end + 1).map(w => w.word).join(' ')\n\n    let slider;\n\n    $: range = { min: 0, max: words.length - 1 }\n\n    onMount(() => {\n        slider = document.getElementById('context-strategy-slider');\n\n        noUiSlider.create(slider, {\n            start: [0, Math.min(DEFAULT_WORDS, words.length) - 1],\n            connect: true,\n            behaviour: 'drag',\n            range,\n            step: 1,\n            format: { \n                from(value) { return parseInt(value); },\n                to(value) { return parseInt(value); }\n            }\n        })\n\n        slider.noUiSlider.on('update', function (values) {\n            chosenEnds.start = values[0];\n            chosenEnds.end = values[1];\n        });\n    });\n\n    $: if(slider) slider.noUiSlider.updateOptions({ range });\n</script>\n\n<style type=\"text/css\" media=\"screen\">\n    #context-strategy-slider {\n        height: 10px;\n    }\n</style>\n\n<div id=\"context-strategy-slider\"></div>\n<textarea readonly rows=3>{selectedContext}</textarea>\n"
  ],
  "names": [],
  "mappings": "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"
}